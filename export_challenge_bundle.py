#!/usr/bin/env python3
"""
export_challenge_bundle.py

Public Legal Record System (PLRS)
Court Export — Challenge Evidence Bundle

Purpose:
    Create a single, court-ready JSON bundle that contains:
        - The full PLRS Challenge record
        - Its canonical cryptographic hash
        - The corresponding public Challenge index entry (if available)
        - A generation timestamp and minimal explanatory metadata

    This bundle is designed to be attached to declarations, affidavits, or
    motion exhibits so that a court or opposing party can independently verify
    the integrity of the Challenge using the standard PLRS tools.

Spec basis:
    - challenge_schema.json
    - Challenge pipeline (normalize → validate_challenge → hash_challenge → index)
    - PUBLIC_INDEX_FORMAT.md (applied to Challenges)
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Any, Dict, List, Optional
from datetime import datetime, timezone


def load_json_file(path: Path) -> Any:
    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as exc:
        raise ValueError(f"Invalid JSON in file: {path}") from exc


def find_challenge_index_entry(
    index_data: List[Dict[str, Any]],
    challenge_id: str
) -> Optional[Dict[str, Any]]:
    """
    Locate the index entry for a given Challenge_ID in a PUBLIC_INDEX_FORMAT-style
    challenge index (as defined by build_challenge_index.py).
    """
    for entry in index_data:
        if entry.get("Challenge_ID") == challenge_id:
            return entry
    return None


def build_challenge_bundle(
    challenge_data: Dict[str, Any],
    challenge_hash: str,
    index_entry: Optional[Dict[str, Any]],
    index_path: Optional[Path] = None
) -> Dict[str, Any]:
    """
    Construct the Challenge Bundle structure.

    The bundle is intentionally simple JSON so that courts, counsel, and experts can:
        - Read it directly
        - Verify it using PLRS tools
        - Attach it as an exhibit or data appendix
    """
    now_utc = datetime.now(timezone.utc).isoformat(timespec="seconds").replace("+00:00", "Z")

    bundle: Dict[str, Any] = {
        "Bundle_Version": "1.0",
        "Bundle_Type": "PLRS_Challenge_Evidence_Bundle",
        "Generated_At_UTC": now_utc,
        "Challenge": challenge_data,
        "Challenge_Hash": challenge_hash,
        "Index_Entry": index_entry,
        "Index_File_Reference": str(index_path) if index_path is not None else None,
        "Verification_Guide": {
            "Tools_Required": [
                "normalize_time.py (if re-normalizing timestamps upstream)",
                "validate_challenge.py",
                "hash_challenge.py",
                "verify_index.py (optional, if Challenges share a unified index)"
            ],
            "Basic_Verification_Steps": [
                "1. Run validate_challenge.py on the Challenge object to confirm schema compliance.",
                "2. Run hash_challenge.py on the Challenge object and confirm the hash matches Challenge_Hash.",
                "3. If Index_Entry is present, confirm Hash matches the Hash field in the challenge index entry.",
                "4. Optionally audit the challenge index file to confirm sequence and integrity."
            ]
        }
    }

    return bundle


def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Create a court-ready PLRS Challenge Evidence Bundle containing the Challenge, "
            "its hash, and (optionally) the corresponding challenge index entry."
        )
    )
    parser.add_argument(
        "challenge_file",
        help="Path to the fully validated Challenge JSON file."
    )
    parser.add_argument(
        "hash_file",
        help="Path to the .hash file generated by hash_challenge.py for this Challenge."
    )
    parser.add_argument(
        "--index",
        dest="index_file",
        default=None,
        help=(
            "Optional path to public_challenge_index.json. If provided, the matching "
            "challenge index entry will be embedded."
        )
    )
    parser.add_argument(
        "--output",
        dest="output_file",
        default=None,
        help="Optional output path for the bundle JSON. "
             "Defaults to Challenge_ID-based name in the current directory."
    )
    return parser


def main(argv=None) -> int:
    parser = build_arg_parser()
    args = parser.parse_args(argv)

    challenge_path = Path(args.challenge_file)
    hash_path = Path(args.hash_file)
    index_path = Path(args.index_file) if args.index_file else None

    # Load Challenge
    try:
        challenge_data = load_json_file(challenge_path)
    except (FileNotFoundError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] {exc}\n")
        return 1

    challenge_id = challenge_data.get("Challenge_ID")
    if not challenge_id:
        sys.stderr.write("[ERROR] Challenge file is missing Challenge_ID.\n")
        return 1

    # Load hash
    try:
        challenge_hash = hash_path.read_text(encoding="utf-8").strip()
        if not challenge_hash:
            raise ValueError("Hash file is empty.")
    except (OSError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] Failed to read hash file: {exc}\n")
        return 1

    # Load index entry if requested
    index_entry: Optional[Dict[str, Any]] = None
    if index_path is not None:
        try:
            index_data = load_json_file(index_path)
            if not isinstance(index_data, list):
                raise ValueError("Challenge index file must contain a JSON array.")
            index_entry = find_challenge_index_entry(index_data, challenge_id)
            if index_entry is None:
                sys.stderr.write(
                    f"[WARN] No challenge index entry found for Challenge_ID={challenge_id} in {index_path}.\n"
                )
        except (FileNotFoundError, ValueError) as exc:
            sys.stderr.write(f"[WARN] Could not load or parse challenge index file: {exc}\n")
            # Proceed without index_entry

    # Build bundle
    bundle = build_challenge_bundle(
        challenge_data=challenge_data,
        challenge_hash=challenge_hash,
        index_entry=index_entry,
        index_path=index_path
    )

    # Determine output path
    if args.output_file:
        out_path = Path(args.output_file)
    else:
        out_name = f"PLRS_ChallengeBundle_{challenge_id}.json"
        out_path = Path(out_name)

    try:
        with out_path.open("w", encoding="utf-8") as f:
            json.dump(bundle, f, indent=2, ensure_ascii=False)
            f.write("\n")
    except OSError as exc:
        sys.stderr.write(f"[ERROR] Failed to write challenge bundle file: {exc}\n")
        return 1

    sys.stdout.write(f"[CHALLENGE BUNDLE CREATED] {out_path}\n")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
