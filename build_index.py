#!/usr/bin/env python3
"""
build_index.py

Public Legal Record System (PLRS)
Public Ledger Append Utility

Purpose:
    Append a verified Event + Hash to a public index file following
    PUBLIC_INDEX_FORMAT.md. Enforces append-only behavior and sequence order.

Spec basis:
    - PUBLIC_INDEX_FORMAT.md
    - PIPELINE.md (Step 5 — Storage & Publication)
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Any, Dict, List


def load_json_file(path: Path) -> Any:
    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as exc:
        raise ValueError(f"Invalid JSON in file: {path}") from exc


def save_json_file(path: Path, data: Any) -> None:
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
        f.write("\n")


def get_next_index_seq(index_data: List[Dict[str, Any]]) -> int:
    if not index_data:
        return 1
    last = index_data[-1]
    return int(last["Index_Seq"]) + 1


def append_to_index(index_path: Path, event: Dict[str, Any], event_hash: str) -> None:
    if index_path.exists():
        index_data = load_json_file(index_path)
        if not isinstance(index_data, list):
            raise ValueError("Index file must contain a JSON array.")
    else:
        index_data = []

    next_seq = get_next_index_seq(index_data)

    entry = {
        "Event_ID": event["Event_ID"],
        "Timestamp_UTC": event["Timestamp_UTC"],
        "Hash": event_hash,
        "Public_Visibility": event["Public_Visibility"],
        "Index_Seq": next_seq
    }

    index_data.append(entry)
    save_json_file(index_path, index_data)


def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Append a PLRS Event and its hash to a public append-only index file."
        )
    )
    parser.add_argument(
        "event_file",
        help="Path to the fully validated Event JSON file."
    )
    parser.add_argument(
        "hash_file",
        help="Path to the .hash file generated by hash_event.py."
    )
    parser.add_argument(
        "--index",
        dest="index_file",
        default="public_index.json",
        help="Path to the public index file (default: public_index.json)."
    )
    return parser


def main(argv=None) -> int:
    parser = build_arg_parser()
    args = parser.parse_args(argv)

    event_path = Path(args.event_file)
    hash_path = Path(args.hash_file)
    index_path = Path(args.index_file)

    try:
        event_data = load_json_file(event_path)
    except (FileNotFoundError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] {exc}\n")
        return 1

    try:
        hash_str = hash_path.read_text(encoding="utf-8").strip()
        if not hash_str:
            raise ValueError("Hash file is empty.")
    except (OSError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] Failed to read hash file: {exc}\n")
        return 1

    try:
        append_to_index(index_path, event_data, hash_str)
    except Exception as exc:
        sys.stderr.write(f"[ERROR] Failed to append to index: {exc}\n")
        return 1

    sys.stdout.write(f"[APPENDED] {event_data['Event_ID']} → {index_path}\n")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
