#!/usr/bin/env python3
"""
export_event_bundle.py

Public Legal Record System (PLRS)
Court Export â€” Event Evidence Bundle

Purpose:
    Create a single, court-ready JSON bundle that contains:
        - The full PLRS Event record
        - Its canonical cryptographic hash
        - The corresponding public index entry (if available)
        - A generation timestamp and minimal explanatory metadata

    This bundle is designed to be attached to declarations, affidavits, or
    motion exhibits so that a court or opposing party can independently verify
    the integrity of the Event using the standard PLRS tools.

Spec basis:
    - SPEC.md
    - schema.json
    - PUBLIC_INDEX_FORMAT.md
    - PIPELINE.md
    - hash_event.py / build_index.py
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Any, Dict, List, Optional
from datetime import datetime, timezone


def load_json_file(path: Path) -> Any:
    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as exc:
        raise ValueError(f"Invalid JSON in file: {path}") from exc


def find_index_entry(
    index_data: List[Dict[str, Any]],
    event_id: str
) -> Optional[Dict[str, Any]]:
    """
    Locate the index entry for a given Event_ID in a PUBLIC_INDEX_FORMAT-style index.
    Returns the entry dict or None if not found.
    """
    for entry in index_data:
        if entry.get("Event_ID") == event_id:
            return entry
    return None


def build_event_bundle(
    event_data: Dict[str, Any],
    event_hash: str,
    index_entry: Optional[Dict[str, Any]],
    index_path: Optional[Path] = None
) -> Dict[str, Any]:
    """
    Construct the Event Bundle structure.

    The bundle is intentionally simple JSON so that courts, counsel, and experts can:
        - Read it directly
        - Verify it using PLRS tools
        - Attach it as an exhibit or data appendix
    """
    now_utc = datetime.now(timezone.utc).isoformat(timespec="seconds").replace("+00:00", "Z")

    bundle: Dict[str, Any] = {
        "Bundle_Version": "1.0",
        "Bundle_Type": "PLRS_Event_Evidence_Bundle",
        "Generated_At_UTC": now_utc,
        "Event": event_data,
        "Event_Hash": event_hash,
        "Index_Entry": index_entry,
        "Index_File_Reference": str(index_path) if index_path is not None else None,
        "Verification_Guide": {
            "Tools_Required": [
                "normalize_time.py (if re-normalizing timestamps upstream)",
                "validate_event.py",
                "hash_event.py",
                "verify_index.py (optional, for full ledger audit)"
            ],
            "Basic_Verification_Steps": [
                "1. Run validate_event.py on the Event object to confirm schema compliance.",
                "2. Run hash_event.py on the Event object and confirm the hash matches Event_Hash.",
                "3. If Index_Entry is present, confirm Hash matches the Hash field in the index entry.",
                "4. Optionally, run verify_index.py on the referenced index file to audit the wider ledger."
            ]
        }
    }

    return bundle


def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Create a court-ready PLRS Event Evidence Bundle containing the Event, "
            "its hash, and (optionally) the corresponding index entry."
        )
    )
    parser.add_argument(
        "event_file",
        help="Path to the fully validated Event JSON file."
    )
    parser.add_argument(
        "hash_file",
        help="Path to the .hash file generated by hash_event.py for this Event."
    )
    parser.add_argument(
        "--index",
        dest="index_file",
        default=None,
        help="Optional path to public_index.json. If provided, the matching index entry will be embedded."
    )
    parser.add_argument(
        "--output",
        dest="output_file",
        default=None,
        help="Optional output path for the bundle JSON. "
             "Defaults to Event_ID-based name in the current directory."
    )
    return parser


def main(argv=None) -> int:
    parser = build_arg_parser()
    args = parser.parse_args(argv)

    event_path = Path(args.event_file)
    hash_path = Path(args.hash_file)
    index_path = Path(args.index_file) if args.index_file else None

    # Load Event
    try:
        event_data = load_json_file(event_path)
    except (FileNotFoundError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] {exc}\n")
        return 1

    event_id = event_data.get("Event_ID")
    if not event_id:
        sys.stderr.write("[ERROR] Event file is missing Event_ID.\n")
        return 1

    # Load hash
    try:
        event_hash = hash_path.read_text(encoding="utf-8").strip()
        if not event_hash:
            raise ValueError("Hash file is empty.")
    except (OSError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] Failed to read hash file: {exc}\n")
        return 1

    # Load index entry if requested
    index_entry: Optional[Dict[str, Any]] = None
    if index_path is not None:
        try:
            index_data = load_json_file(index_path)
            if not isinstance(index_data, list):
                raise ValueError("Index file must contain a JSON array.")
            index_entry = find_index_entry(index_data, event_id)
            if index_entry is None:
                sys.stderr.write(
                    f"[WARN] No index entry found for Event_ID={event_id} in {index_path}.\n"
                )
        except (FileNotFoundError, ValueError) as exc:
            sys.stderr.write(f"[WARN] Could not load or parse index file: {exc}\n")
            # Proceed without index_entry

    # Build bundle
    bundle = build_event_bundle(
        event_data=event_data,
        event_hash=event_hash,
        index_entry=index_entry,
        index_path=index_path
    )

    # Determine output path
    if args.output_file:
        out_path = Path(args.output_file)
    else:
        out_name = f"PLRS_EventBundle_{event_id}.json"
        out_path = Path(out_name)

    try:
        with out_path.open("w", encoding="utf-8") as f:
            json.dump(bundle, f, indent=2, ensure_ascii=False)
            f.write("\n")
    except OSError as exc:
        sys.stderr.write(f"[ERROR] Failed to write bundle file: {exc}\n")
        return 1

    sys.stdout.write(f"[BUNDLE CREATED] {out_path}\n")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
