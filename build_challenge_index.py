#!/usr/bin/env python3
"""
build_challenge_index.py

Public Legal Record System (PLRS)
Public Challenge Ledger Append Utility

Purpose:
    Append a verified Challenge + Hash to a public challenge index file
    following the same append-only guarantees as Events.

Spec basis:
    - challenge_schema.json
    - PIPELINE.md (Challenge extension of Step 5 — Storage & Publication)
    - PUBLIC_INDEX_FORMAT.md (shared index principles)
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Any, Dict, List


def load_json_file(path: Path) -> Any:
    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as exc:
        raise ValueError(f"Invalid JSON in file: {path}") from exc


def save_json_file(path: Path, data: Any) -> None:
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
        f.write("\n")


def get_next_index_seq(index_data: List[Dict[str, Any]]) -> int:
    if not index_data:
        return 1
    last = index_data[-1]
    return int(last["Index_Seq"]) + 1


def append_to_challenge_index(
    index_path: Path,
    challenge: Dict[str, Any],
    challenge_hash: str
) -> None:
    if index_path.exists():
        index_data = load_json_file(index_path)
        if not isinstance(index_data, list):
            raise ValueError("Challenge index file must contain a JSON array.")
    else:
        index_data = []

    next_seq = get_next_index_seq(index_data)

    entry = {
        "Challenge_ID": challenge["Challenge_ID"],
        "Challenged_Event_ID": challenge["Challenged_Event_ID"],
        "Timestamp_UTC": challenge["Timestamp_UTC"],
        "Hash": challenge_hash,
        "Public_Visibility": challenge["Public_Visibility"],
        "Index_Seq": next_seq
    }

    index_data.append(entry)
    save_json_file(index_path, index_data)


def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Append a PLRS Challenge and its hash to a public append-only "
            "challenge index file."
        )
    )
    parser.add_argument(
        "challenge_file",
        help="Path to the fully validated Challenge JSON file."
    )
    parser.add_argument(
        "hash_file",
        help="Path to the .hash file generated by hash_challenge.py."
    )
    parser.add_argument(
        "--index",
        dest="index_file",
        default="public_challenge_index.json",
        help="Path to the Challenge index file (default: public_challenge_index.json)."
    )
    return parser


def main(argv=None) -> int:
    parser = build_arg_parser()
    args = parser.parse_args(argv)

    challenge_path = Path(args.challenge_file)
    hash_path = Path(args.hash_file)
    index_path = Path(args.index_file)

    try:
        challenge_data = load_json_file(challenge_path)
    except (FileNotFoundError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] {exc}\n")
        return 1

    try:
        hash_str = hash_path.read_text(encoding="utf-8").strip()
        if not hash_str:
            raise ValueError("Hash file is empty.")
    except (OSError, ValueError) as exc:
        sys.stderr.write(f"[ERROR] Failed to read hash file: {exc}\n")
        return 1

    try:
        append_to_challenge_index(index_path, challenge_data, hash_str)
    except Exception as exc:
        sys.stderr.write(f"[ERROR] Failed to append to challenge index: {exc}\n")
        return 1

    sys.stdout.write(
        f"[APPENDED] {challenge_data['Challenge_ID']} → {index_path}\n"
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
